# -*- coding: utf-8 -*-
"""
Binance USDT æ°¸ç»­ Â· å¤šç­–ç•¥åŽ†å²å›žæµ‹å™¨ï¼ˆæ­¢ç›ˆ 2% ç‰ˆï¼‰
- éšæœº 10 ä¸ªåˆçº¦
- åŽ†å² 500 æ ¹ K çº¿
- 1H / 30m å¤šç­–ç•¥
- å›ºå®šæ­¢ç›ˆ 2%
- 20U Ã— 20 æ æ†
- è¾“å‡º CSV äº¤æ˜“æ˜Žç»†
"""

import requests
import pandas as pd
import random
from datetime import timedelta

# ================== å‚æ•° ==================
BASE_URL = "https://fapi.binance.com"
TIME_OFFSET = timedelta(hours=8)

SYMBOL_SAMPLE = 10
KLINE_LIMIT = 500

CAPITAL = 20
LEVERAGE = 20
POSITION_SIZE = CAPITAL * LEVERAGE

TP_PCT = 0.02   # â­æ­¢ç›ˆ 2%

OUT_CSV = "backtest_trades_tp2.csv"

# ================== ç½‘ç»œ ==================
def safe_get(url, params=None, retry=3):
    for _ in range(retry):
        try:
            r = requests.get(url, params=params, timeout=10)
            if r.status_code == 200:
                return r.json()
        except:
            pass
    return None

# ================== åˆçº¦ ==================
def get_all_usdt_symbols():
    data = safe_get(f"{BASE_URL}/fapi/v1/exchangeInfo")
    return [
        s["symbol"]
        for s in data["symbols"]
        if s["quoteAsset"] == "USDT"
        and s["contractType"] == "PERPETUAL"
        and s["status"] == "TRADING"
    ]

# ================== Kçº¿ ==================
def fetch_klines(symbol, interval, limit):
    data = safe_get(
        f"{BASE_URL}/fapi/v1/klines",
        params={"symbol": symbol, "interval": interval, "limit": limit}
    )
    if not data:
        return None

    df = pd.DataFrame(data, columns=[
        "open_time","open","high","low","close","volume",
        "close_time","qav","trades","tbb","tbq","ignore"
    ])

    for c in ["open","high","low","close","volume"]:
        df[c] = df[c].astype(float)

    df["time"] = pd.to_datetime(df["open_time"], unit="ms") + TIME_OFFSET
    return df[["time","open","high","low","close","volume"]]

# ================== Kçº¿å·¥å…· ==================
def is_bull(k): return k["close"] > k["open"]
def is_bear(k): return k["close"] < k["open"]

# ================== ç­–ç•¥ ==================
def A_SHORT(df, i):
    if i < 3: return False
    k = df.iloc[i]
    avg_vol = df["volume"][i-3:i].mean()
    body = abs(k["close"] - k["open"])
    if body == 0: return False
    upper = k["high"] - max(k["open"], k["close"])
    return is_bull(k) and k["volume"] >= avg_vol * 1.2 and upper / body >= 1.5

def L1_SHORT(df, i):
    if i < 1: return False
    prev, cur = df.iloc[i-1], df.iloc[i]
    rise = (prev["close"] - prev["open"]) / prev["open"]
    return rise >= 0.03 and is_bull(prev) and is_bear(cur)

def L2_LONG(df, i):
    if i < 4: return False
    seg = df.iloc[i-4:i-1]
    cur = df.iloc[i]
    if not all(seg["close"] < seg["open"]): return False
    drop = (seg.iloc[0]["open"] - seg.iloc[-1]["close"]) / seg.iloc[0]["open"]
    vol_ratio = cur["volume"] / seg["volume"].mean()
    return drop >= 0.04 and vol_ratio <= 0.8

# ================== å›žæµ‹ï¼ˆæ­¢ç›ˆ 2%ï¼‰ ==================
def backtest(symbol, df, timeframe):
    trades = []
    pos = None

    for i in range(len(df) - 1):
        bar = df.iloc[i]

        # å¼€ä»“
        if pos is None:
            if timeframe == "1h" and A_SHORT(df, i):
                entry = df.iloc[i+1]
                pos = ("SHORT", "A_SHORT", entry)

            elif timeframe == "30m" and L1_SHORT(df, i):
                entry = df.iloc[i+1]
                pos = ("SHORT", "L1_SHORT", entry)

            elif timeframe == "30m" and L2_LONG(df, i):
                entry = df.iloc[i+1]
                pos = ("LONG", "L2_LONG", entry)

        # æŒä»“æ£€æŸ¥æ­¢ç›ˆ
        else:
            direction, strategy, entry = pos
            entry_price = entry["open"]

            if direction == "LONG":
                tp_price = entry_price * (1 + TP_PCT)
                if bar["high"] >= tp_price:
                    pnl = TP_PCT * POSITION_SIZE
                else:
                    continue

            else:
                tp_price = entry_price * (1 - TP_PCT)
                if bar["low"] <= tp_price:
                    pnl = TP_PCT * POSITION_SIZE
                else:
                    continue

            trades.append({
                "symbol": symbol,
                "timeframe": timeframe,
                "strategy": strategy,
                "direction": direction,
                "entry_time": entry["time"],
                "entry_price": entry_price,
                "exit_time": bar["time"],
                "exit_price": round(tp_price, 6),
                "pnl_usdt": round(pnl, 2),
                "leverage": LEVERAGE
            })

            pos = None

    return trades

# ================== ä¸»ç¨‹åº ==================
def main():
    symbols = random.sample(get_all_usdt_symbols(), SYMBOL_SAMPLE)
    print("ðŸŽ¯ å›žæµ‹åˆçº¦ï¼š", symbols)

    all_trades = []

    for s in symbols:
        df1 = fetch_klines(s, "1h", KLINE_LIMIT)
        df30 = fetch_klines(s, "30m", KLINE_LIMIT)

        if df1 is not None:
            all_trades += backtest(s, df1, "1h")
        if df30 is not None:
            all_trades += backtest(s, df30, "30m")

    df_out = pd.DataFrame(all_trades)
    df_out.to_csv(OUT_CSV, index=False, encoding="utf-8-sig")

    print(f"\nâœ… å›žæµ‹å®Œæˆ")
    print(f"ðŸ“„ äº¤æ˜“æ•°ï¼š{len(df_out)}")
    print(f"ðŸ“ CSV æ–‡ä»¶ï¼š{OUT_CSV}")

if __name__ == "__main__":
    main()
