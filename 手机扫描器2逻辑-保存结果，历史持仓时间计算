# -*- coding: utf-8 -*-
"""
ğŸ“± Pydroidï½œå®æ—¶ä¿¡å·æ‰«æ + å†å²æœ€å¤§å›æ’¤åˆ†æï¼ˆæœ¬åœ°ä¿å­˜ä¿®æ­£ç‰ˆï¼‰
"""

import requests
import pandas as pd
import time
import os
from datetime import datetime

# ================== å‚æ•° ==================
BASE_URL = "https://fapi.binance.com"
INVEST = 20
LEVERAGE = 20
TP = 0.02
KLINE_LIMIT = 5
BLACKLIST = ["TRXUSDT"]

BASE_DIR = "/storage/emulated/0/Download/binance_scan"
os.makedirs(BASE_DIR, exist_ok=True)

TIME_TAG = datetime.now().strftime("%Y%m%d_%H%M%S")
OUTPUT_FILE = f"{BASE_DIR}/realtime_signal_{TIME_TAG}.csv"

HISTORY_FILE = "/storage/emulated/0/Download/logic17_trades_STRICT.csv"

# ================== è¯»å–å†å² ==================
if os.path.exists(HISTORY_FILE):
    trades_df = pd.read_csv(HISTORY_FILE)
    trades_df["entry_date"] = pd.to_datetime(trades_df["entry_date"])
else:
    trades_df = pd.DataFrame()

# ================== Binance ==================
def get_symbols():
    r = requests.get(f"{BASE_URL}/fapi/v1/exchangeInfo", timeout=10).json()
    return [
        s["symbol"] for s in r.get("symbols", [])
        if s["quoteAsset"] == "USDT" and s["status"] == "TRADING"
    ]

def fetch_k(symbol):
    r = requests.get(
        f"{BASE_URL}/fapi/v1/klines",
        params={"symbol": symbol, "interval": "1d", "limit": KLINE_LIMIT},
        timeout=10
    ).json()
    if not isinstance(r, list) or len(r) < KLINE_LIMIT:
        return None
    df = pd.DataFrame(r, columns=[
        "t","open","high","low","close","v","ct","qv","n","tb","tq","i"
    ])
    df[["open","close"]] = df[["open","close"]].astype(float)
    return df

# ================== é€»è¾‘ ==================
def down(c): 
    return c["close"] < c["open"]

def B_4DOWN_LONG(df):
    return len(df) >= 5 and all(down(df.iloc[i]) for i in range(-5, -1))

def BIG_GREEN_THEN_RED_SHORT(df):
    prev, last = df.iloc[-2], df.iloc[-1]
    return prev["close"] > prev["open"] * 1.07 and down(last)

# ================== å†å²æœ€å¤§å›æ’¤ ==================
def analyze_drawdown(symbol, logic):
    d = trades_df[(trades_df["symbol"] == symbol) & (trades_df["logic"] == logic)]
    if d.empty:
        return {}
    worst = d.loc[d["max_dd"].idxmax()]
    others = d.drop(worst.name)
    return {
        "max_dd": round(worst["max_dd"], 2),
        "dd_date": worst["entry_date"].date(),
        "dd_entry": worst["entry_price"],
        "dd_held": int(worst["held_days"]),
        "avg_hold_excl": round(others["held_days"].mean(), 2) if not others.empty else None
    }

# ================== å¯åŠ¨ ==================
symbols = get_symbols()
results = []

print("=" * 80)
print("ğŸ“± å®æ—¶æ‰«æ + æœ€å¤§å›æ’¤èƒŒæ™¯åˆ†æ")
print("æ—¶é—´ï¼š", datetime.now())
print("ğŸ“ ä¿å­˜ç›®å½•ï¼š", BASE_DIR)
print("=" * 80)

for symbol in symbols:
    if symbol in BLACKLIST:
        continue

    df = fetch_k(symbol)
    if df is None:
        continue

    signals = []
    if B_4DOWN_LONG(df):
        signals.append(("B_4DOWN_LONG", "LONG"))
    if BIG_GREEN_THEN_RED_SHORT(df):
        signals.append(("BIG_GREEN_THEN_RED_SHORT", "SHORT"))

    if not signals:
        continue

    entry = df.iloc[-1]["open"]
    profit_u = round(INVEST * LEVERAGE * TP, 2)

    print(f"\nğŸš¨ {symbol}")

    for logic, direction in signals:
        tp = round(entry * (1 + TP), 6) if direction == "LONG" else round(entry * (1 - TP), 6)
        dd = analyze_drawdown(symbol, logic)

        print(f"  {'ğŸŸ¢' if direction=='LONG' else 'ğŸ”´'} {logic}ï½œ{direction}")

        results.append({
            "scan_time": datetime.now(),
            "symbol": symbol,
            "logic": logic,
            "direction": direction,
            "entry_price": entry,
            "tp": tp,
            **dd
        })

    time.sleep(0.3)

# ================== å¼ºåˆ¶ä¿å­˜ï¼ˆå³ä½¿æ²¡ä¿¡å·ï¼‰ ==================
df_out = pd.DataFrame(results)
df_out.to_csv(OUTPUT_FILE, index=False, encoding="utf-8-sig")

print("\n" + "=" * 80)
print("âœ… æ‰«æå®Œæˆ")
print("ğŸ“ CSV å·²ä¿å­˜ï¼š")
print(OUTPUT_FILE)
print(f"ğŸ“Š ä¿¡å·æ¡æ•°ï¼š{len(df_out)}")
print("=" * 80)
