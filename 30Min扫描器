# -*- coding: utf-8 -*-
"""
Binance USDT æ°¸ç»­ Â· å…¨å¸‚åœºå®žç›˜æ‰«æå™¨ï¼ˆå¯è§è¿›åº¦ç‰ˆï¼‰
30m å‘¨æœŸï½œåªæ‰«æä¸ä¸‹å•
"""

import requests
import pandas as pd
import time
from datetime import datetime, timezone

BASE_URL = "https://fapi.binance.com"
INTERVAL = "30m"
KLINE_LIMIT = 10
SLEEP = 60  # æ¯åˆ†é’Ÿä¸€è½®

# ================== ç½‘ç»œ ==================
def safe_get(url, params=None, retry=3):
    for _ in range(retry):
        try:
            r = requests.get(url, params=params, timeout=10)
            if r.status_code == 200:
                return r.json()
        except:
            time.sleep(1)
    return None

# ================== åˆçº¦ ==================
def get_all_symbols():
    data = safe_get(f"{BASE_URL}/fapi/v1/exchangeInfo")
    return [
        s['symbol'] for s in data['symbols']
        if s['quoteAsset'] == 'USDT'
        and s['status'] == 'TRADING'
        and s['contractType'] == 'PERPETUAL'
    ]

# ================== Kçº¿ ==================
def fetch_klines(symbol):
    data = safe_get(
        f"{BASE_URL}/fapi/v1/klines",
        params={
            "symbol": symbol,
            "interval": INTERVAL,
            "limit": KLINE_LIMIT
        }
    )
    if not data:
        return None

    df = pd.DataFrame(data, columns=[
        "open_time","open","high","low","close","volume",
        "close_time","qav","trades","tbb","tbq","ignore"
    ])

    df['time'] = (
        pd.to_datetime(df['open_time'], unit='ms', utc=True)
        .dt.tz_convert('Asia/Shanghai')
        .dt.tz_localize(None)
    )

    for c in ['open','high','low','close','volume']:
        df[c] = df[c].astype(float)

    return df[['time','open','high','low','close','volume']]

# ================== Kçº¿å·¥å…· ==================
def is_bull(k): return k['close'] > k['open']
def is_bear(k): return k['close'] < k['open']

# ================== L1 SHORT ==================
def L1_SHORT(df):
    prev = df.iloc[-2]
    cur  = df.iloc[-1]
    rise = (prev['close'] - prev['open']) / prev['open']
    return rise >= 0.03 and is_bull(prev) and is_bear(cur)

# ================== L2 LONG ==================
def L2_LONG(df):
    seg = df.iloc[-4:-1]
    cur = df.iloc[-1]

    if not all(seg['close'] < seg['open']):
        return False

    drop = (seg.iloc[0]['open'] - seg.iloc[-1]['close']) / seg.iloc[0]['open']
    vol_ratio = cur['volume'] / seg['volume'].mean()

    return drop >= 0.04 and vol_ratio <= 0.8

# ================== æ‰«æ ==================
def scan():
    symbols = get_all_symbols()
    start = time.time()

    print("\n" + "="*100)
    print(f"ðŸ•’ æ‰«æå¼€å§‹ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰ï¼š{datetime.now()}")
    print(f"ðŸ“Š åˆçº¦æ€»æ•°ï¼š{len(symbols)}")

    for i, s in enumerate(symbols, 1):
        df = fetch_klines(s)

        print("\n" + "-"*80)
        print(f"[{i}/{len(symbols)}] æ‰«æ {s}")

        if df is None or len(df) < 5:
            print("âš ï¸ Kçº¿ä¸è¶³ / æ‹‰å–å¤±è´¥")
            print("ðŸ‘‰ çŽ°åœ¨è¯¥å¹²å˜›ï¼šè·³è¿‡")
            continue

        hit = False

        if L1_SHORT(df):
            hit = True
            print("ðŸš¨ å‘½ä¸­ L1 SHORTï¼ˆè¯±å¤šå›žè½ï¼‰")
            print("ðŸ‘‰ çŽ°åœ¨è¯¥å¹²å˜›ï¼šä¸‹ä¸€æ ¹ 30m å¼€ç›˜ã€åšç©ºã€‘")

        if L2_LONG(df):
            hit = True
            print("ðŸŸ¢ å‘½ä¸­ L2 LONGï¼ˆææ…Œè¡°ç«­åå¼¹ï¼‰")
            print("ðŸ‘‰ çŽ°åœ¨è¯¥å¹²å˜›ï¼šä¸‹ä¸€æ ¹ 30m å¼€ç›˜ã€åšå¤šã€‘")

        if not hit:
            print("âŒ æœªå‘½ä¸­ä»»ä½•ç­–ç•¥")
            print("ðŸ‘‰ çŽ°åœ¨è¯¥å¹²å˜›ï¼šå¿½ç•¥è¯¥åˆçº¦ï¼Œç»§ç»­æ‰«æ")

    cost = time.time() - start
    print("\n" + "="*100)
    print(f"âœ… æœ¬è½®æ‰«æå®Œæˆï¼Œç”¨æ—¶ {cost:.1f} ç§’")


# ================== ä¸»å¾ªçŽ¯ ==================
def main():
    print("ðŸš€ Binance å…¨å¸‚åœº 30m å®žç›˜æ‰«æå™¨å¯åŠ¨")
    while True:
        scan()
        time.sleep(SLEEP)

if __name__ == "__main__":
    main()
