# -*- coding: utf-8 -*-
"""
逻辑回测：4天连续阴做多 + 大阳反包做空
止盈: 2%
数据：all_usdt_perp_1d_20260101_1005.csv
输出：每笔交易详细信息
"""

import pandas as pd
import os
from tqdm import tqdm

# ================= 参数 =================
DATA_FILE = r"C:\Users\JZDD\Desktop\all_usdt_perp_1d_20260101_1005.csv"
OUTPUT_DIR = r"C:\Users\JZDD\Desktop\backtest_logic1_logic2"
INVEST = 20
LEVERAGE = 20
TP = 2  # 止盈2%
BLACKLIST = {
    "BTCUSDT","ETHUSDT","BNBUSDT","SOLUSDT","XRPUSDT","DOGEUSDT",
    "ADAUSDT","AVAXUSDT","LTCUSDT","BCHUSDT","TONUSDT"
}

os.makedirs(OUTPUT_DIR, exist_ok=True)

# ================= 读取数据 =================
df = pd.read_csv(DATA_FILE)
if 'date' in df.columns:
    df['date'] = pd.to_datetime(df['date'])
elif 'open_time' in df.columns:
    df['date'] = pd.to_datetime(df['open_time'], unit='ms')
else:
    raise ValueError("找不到时间字段 date / open_time")

df = df.sort_values(['symbol', 'date']).reset_index(drop=True)
symbols = [s for s in df['symbol'].unique() if s not in BLACKLIST]

# ================= K线工具 =================
def candle_down(row):
    return row['close'] < row['open']

# ================= 逻辑 =================
def trigger_B_4DOWN_LONG(df_s, idx):
    if idx < 4:
        return False
    return all(candle_down(df_s.iloc[i]) for i in range(idx-4, idx))

def trigger_BIG_GREEN_THEN_RED_SHORT(df_s, idx):
    if idx < 1:
        return False
    prev = df_s.iloc[idx-1]
    last = df_s.iloc[idx]
    return (prev['close'] > prev['open']*1.07) and candle_down(last)

# ================= 单币回测 =================
def backtest_symbol(df_s, tp):
    trades_l1 = []
    trades_l2 = []

    for i in range(4, len(df_s)):
        row = df_s.iloc[i]

        # 逻辑1
        if trigger_B_4DOWN_LONG(df_s, i):
            entry_price = row['open']
            tp_price = entry_price * (1 + tp/100)
            entry_date = row['date']
            max_dd = 0
            held_days = 0
            exit_price = None
            exit_date = None

            for j in range(i, len(df_s)):
                high = df_s.iloc[j]['high']
                low = df_s.iloc[j]['low']
                held_days += 1
                dd = (entry_price - low)/entry_price * LEVERAGE * INVEST
                max_dd = max(max_dd, dd)
                if high >= tp_price:
                    exit_price = tp_price
                    exit_date = df_s.iloc[j]['date']
                    break
            if exit_price is None:
                exit_price = df_s.iloc[-1]['close']
                exit_date = df_s.iloc[-1]['date']

            trades_l1.append({
                "symbol": df_s.iloc[i]['symbol'],
                "logic": "4DOWN_LONG",
                "entry_date": entry_date,
                "entry_price": entry_price,
                "exit_date": exit_date,
                "exit_price": exit_price,
                "profit": (exit_price - entry_price)/entry_price * LEVERAGE * INVEST,
                "held_days": held_days,
                "max_drawdown": max_dd
            })

        # 逻辑2
        if trigger_BIG_GREEN_THEN_RED_SHORT(df_s, i):
            entry_price = row['open']
            tp_price = entry_price * (1 - tp/100)
            entry_date = row['date']
            max_dd = 0
            held_days = 0
            exit_price = None
            exit_date = None

            for j in range(i, len(df_s)):
                high = df_s.iloc[j]['high']
                low = df_s.iloc[j]['low']
                held_days += 1
                dd = (high - entry_price)/entry_price * LEVERAGE * INVEST
                max_dd = max(max_dd, dd)
                if low <= tp_price:
                    exit_price = tp_price
                    exit_date = df_s.iloc[j]['date']
                    break
            if exit_price is None:
                exit_price = df_s.iloc[-1]['close']
                exit_date = df_s.iloc[-1]['date']

            trades_l2.append({
                "symbol": df_s.iloc[i]['symbol'],
                "logic": "BIG_GREEN_THEN_RED_SHORT",
                "entry_date": entry_date,
                "entry_price": entry_price,
                "exit_date": exit_date,
                "exit_price": exit_price,
                "profit": (entry_price - exit_price)/entry_price * LEVERAGE * INVEST,
                "held_days": held_days,
                "max_drawdown": max_dd
            })

    return trades_l1, trades_l2

# ================= 主回测 =================
all_trades_l1 = []
all_trades_l2 = []

print(f"=== 开始回测 止盈 {TP}% ===")
for sym in tqdm(symbols, desc="回测进度"):
    df_s = df[df['symbol']==sym].reset_index(drop=True)
    if len(df_s) < 10:
        continue
    t1, t2 = backtest_symbol(df_s, TP)
    all_trades_l1.extend(t1)
    all_trades_l2.extend(t2)

# 统计逻辑1
df_l1 = pd.DataFrame(all_trades_l1)
if not df_l1.empty:
    wins = df_l1[df_l1['profit']>0]
    losses = df_l1[df_l1['profit']<=0]
    print(f"\n[逻辑1 4DOWN_LONG] 止盈 {TP}% 总览")
    print(f"触发次数: {len(df_l1)} | 盈利: {len(wins)} | 亏损: {len(losses)} | 胜率: {len(wins)/len(df_l1)*100:.2f}%")
    print(f"总盈利: {wins['profit'].sum():.2f} USDT | 总亏损: {losses['profit'].sum():.2f} USDT | 净收益: {df_l1['profit'].sum():.2f} USDT")
    print(f"平均抗单天数: {df_l1['held_days'].mean():.2f} | 最大浮亏: {df_l1['max_drawdown'].max():.2f} USDT")

# 统计逻辑2
df_l2 = pd.DataFrame(all_trades_l2)
if not df_l2.empty:
    wins = df_l2[df_l2['profit']>0]
    losses = df_l2[df_l2['profit']<=0]
    print(f"\n[逻辑2 BIG_GREEN_THEN_RED_SHORT] 止盈 {TP}% 总览")
    print(f"触发次数: {len(df_l2)} | 盈利: {len(wins)} | 亏损: {len(losses)} | 胜率: {len(wins)/len(df_l2)*100:.2f}%")
    print(f"总盈利: {wins['profit'].sum():.2f} USDT | 总亏损: {losses['profit'].sum():.2f} USDT | 净收益: {df_l2['profit'].sum():.2f} USDT")
    print(f"平均抗单天数: {df_l2['held_days'].mean():.2f} | 最大浮亏: {df_l2['max_drawdown'].max():.2f} USDT")

# 保存详细交易明细
pd.concat([df_l1, df_l2]).to_csv(os.path.join(OUTPUT_DIR, f"backtest_TP{TP}.csv"), index=False)
print(f"✅ 交易明细已保存: {OUTPUT_DIR}\\backtest_TP{TP}.csv")
